    // Release curve
    // ========================================================================================

    // Address for the pre-calculated release curve points
    address public release_curve_contract_address;
    IArthBond_Curve private RELEASE_CURVE;
    uint8 release_curve_choice;


    // Maximum number of ARTHB tokens that should be floating outside the contract
    // The goal is to do a smooth release so price spikes don't happen
    function max_arthb_releaseable() public view returns (uint256 max_arthb_releaseable) {
        if (isInEpoch()) {
            uint256 time_into_epoch = (block.timestamp).sub(epoch_start);
            if(useCurve) {
                // Given n points on the curve, find the nearest one
                // e.g. 100 points total, if the time_into_epoch is 50% of the epoch length, nearest_curve_index should be 50

                uint256 release_curve_total_points = uint256(RELEASE_CURVE.get_total_points(release_curve_choice));

                // Truncation desired
                uint256 nearest_curve_index = ((release_curve_total_points).mul(time_into_epoch)) / epoch_length;

                // Failsafe to avoid out-of-bounds array
                // Otherwise proceed normally
                if (nearest_curve_index == release_curve_total_points) max_arthb_releaseable = max_arthb_outstanding;
                else {
                    uint256 max_arthb_releaseable = max_arthb_outstanding.mul(RELEASE_CURVE.get_curve_point(release_curve_choice, uint8(nearest_curve_index))).div(PRICE_PRECISION);
                }
            }
            else {
                // Use linear
                max_arthb_releaseable = max_arthb_outstanding.mul(time_into_epoch).div(epoch_length);
            }
        }
        else {
            // No selling outside of an epoch
            max_arthb_releaseable = 0;
        }

    }


    function setReleaseCurveContractAndChoice(address _release_curve_contract_address, uint8 _release_curve_choice) external onlyByOwnerOrGovernance {
        release_curve_contract_address = _release_curve_contract_address;
        release_curve_choice = _release_curve_choice;
        RELEASE_CURVE = IArthBond_Curve(_release_curve_contract_address);
        require(RELEASE_CURVE.get_total_points(release_curve_choice) != 0, "Invalid curve address or choice");
        require(RELEASE_CURVE.get_curve_point(release_curve_choice, 1) != 0, "Invalid curve point");
    }

    function toggleUseCurve() external {
        require(hasRole(USE_CURVE_TOGGLER, msg.sender));
        useCurve = !useCurve;
    }






    // AMM floor sell under floor price
    // ========================================================================================


    function sellARTHBintoAMM(uint256 arthb_amount, uint256 ARTHOutMin) external notSellingPaused returns (uint256 arthb_sold_under_floor, uint256 arth_out, uint256 arth_fee_amt) {
        require(isInEpoch(), 'Not in an epoch');

        uint256 the_floor_price = floor_price();
        uint256 amm_price = amm_spot_price();

        arthb_sold_under_floor = 0;

        // The AMM will buy back ARTHB at market rates in all cases
        // However, any ARTHB bought back under the floor price will be burned
        uint256 max_market_sellable_arthb = maximum_arthb_AMM_sellable_above_floor();
        if(arthb_amount > max_market_sellable_arthb){
            arthb_sold_under_floor = arthb_amount.sub(max_market_sellable_arthb);
        }
        else {
            arthb_sold_under_floor = 0;
        }

        // Get the expected amount of ARTH via the AMM from the market-priced portion
        arth_out = getAmountOutNoFee(arthb_amount, ARTHB.balanceOf(address(this)), ARTH.balanceOf(address(this)));

        // Apply the normal selling fee
        arth_fee_amt = arth_out.mul(selling_fee).div(PRICE_PRECISION);
        arth_out = arth_out.sub(arth_fee_amt);

        // Check ARTHOutMin
        require(arth_out >= ARTHOutMin, "[sellARTHBintoAMM ARTHOutMin]: Slippage limit reached");

        // AMM will never allow an effective sale price above 1
        {
            uint256 effective_sale_price = arth_out.mul(PRICE_PRECISION).div(arthb_amount);
            require(effective_sale_price <= PRICE_PRECISION, "[sellARTHBintoAMM]: Effective sale price is above 1");
        }

        // Take ARTHB from the sender
        ARTHB.transferFrom(msg.sender, address(this), arthb_amount);

        // If any ARTHB was sold under the floor price, retire / burn it
        // This is less ARTHB that will have to be redeemed at full value later and is essentially a protocol-level profit
        if (arthb_sold_under_floor > 0){
            ARTHB.burn(arthb_sold_under_floor);
        }

        // Give ARTH to sender
        ARTH.transfer(msg.sender, arth_out);

        // Safety checks (must be done after the transfers in this case)
        // Tx will still revert if not true
        {
            uint256 amm_price = amm_spot_price();

            // The spot price should not land above 1 after a sale
            require(amm_price <= PRICE_PRECISION, "[sellARTHBintoAMM]: Spot price is above 1");

            // It is ok for the AMM to buy back ARTHB below the floor price and retire it, as this is basically a discount
            // and less money it will have to pay back later
        }
    }
